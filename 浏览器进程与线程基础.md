# 电脑的 CPU 与程序资源的对应关系

### 核心与并发

- cpu 计算以核心为独立单元，核心中不论有几个程序进程和程序线程在执行，其实都不是并行的，只是有类似于 js 的异步模式+时间片切换模式，使得这些程序线程看起来好像在同步执行。
- 不同的核心之间才是真正的并发，但也受限于 IO 等其他资源的使用
- 超线程技术，生成的新线程可以理解为新的核心，可以和物理核心并行计算，但优先级更低，有可能被挂起，所以比真正的多核心还是差点意思。
- 超线程模式在执行多个小算量任务时有明显优势，在执行单个大算量任务时反而不如不启用

### 程序进程、线程的执行

- 一个进程只能在一个核心中运行，比如在 4 核 8 线程处理器中，执行多个视频转码，他可以每个转码使用一个进程，大幅提高计算速度。但是！如果生成的数据速度之和，大于硬盘读写速度（还有硬盘缓存之类的东西不展开讲）上限，计算速度就会被限制，无法发挥 cpu 性能极限。
  - 计算密集型不需要外设支持也能发挥 cpu 性能
  - IO 密集型、请求密集型等必须匹配差不多的硬盘和内存等设备、网络吞吐能力等
- 一个核心中可能有多个进程在执行，没有具体的数量限制
- 并发的程序线程越多，多核多线程 cpu 能效越高，现代场景中并发的程序线程通常是很多的，所以即使 8 线程的 CPU 能效比也不低

# 浏览器进程线程

https://segmentfault.com/a/1190000012925872 写的还行

- 程序进程里可能有多个程序线程，略
- 浏览器的主要进程：
  - 浏览器的主进程：只有一个，负责浏览器界面操作、打开关闭标签、请求、资源控制等
  - 第三方插件进程：每个插件对应一个，启用了才有
  - GPU 进程：只有一个，用于 3D 绘制（手表有）
  - 渲染进程：每个标签页对应一个
    - 多个空白页只使用一个进程

# 渲染进程（也叫内核进程、浏览器的主进程）

- 进程可以拆到多个核中执行，但线程只能在一个核中相对并行
- 包含多个线程，主要如下：

### 图形用户界面 GUI 渲染线程

- 负责渲染浏览器界面，包括解析 HTML、CSS、构建 DOM 树、Render 树、布局与绘制等
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

### JS 引擎线程

- 负责执行 js 代码

### 事件触发线程

- 所有被触发的回调都放在里面，排队等待执行
- 监听 dom 事件

### 定时器线程

- 跑定时器，每次回调的时候，将函数添加到事件触发线程中

### 请求线程

- 每个请求都新建一个线程（具体比较复杂不展开讲），回调的时候，将函数添加到事件触发线程中

# JS 单线程的原因

- js 设计初衷，主要目的是处理用户行为，用户不是三头六臂没必要多并发
- 如果设计成多线程模式，会发生抢占资源的情况，没必要为了少量的并发需求大幅增加设计复杂度
- 通过增加浏览器线程来实现少数的并发需求

# 浏览器内核中线程之间的关系

### GUI 渲染线程与 JS 引擎线程互斥

- 虽然是不同线程，但被设置成了不能并行的关系。因为渲染过程中可能 js 修改了界面，也可能查询界面中的位置等数据，互相死锁

### JS 引擎线程与事件触发线程、定时触发器线程、异步 HTTP 请求线程

- 回调触发时会推入到事件线程中，js 线程执行完毕后才去查询事件线程里可执行的部分并执行。
- 主要涉及到事件循环，每个循环中宏任务优先于微任务。宏任务执行完查询是否有可执行的微任务并执行。
- 单个循环执行完毕后，会查询是否有新的宏任务可执行
- js 脚本是宏任务，promise 是微任务
  - 多个 script 标签是多个宏任务
  - 比如有两个 script 标签，第一个里面 settimeout 0 第二个里面 log 一个值，会先打印第二个 script 里面的 log。是因为 settimeout 的最小单位是 4ms
    - 即使 script 标签被 html 隔断，且被 GUI 线程互斥，也仅仅是被挂起，不会结束当前的宏任务
    - 所以在 head 中添加的 document 的 DOMContentLoaded 回调，会在 body 中的 script 执行后才能执行
  - settimeout 有两个有趣的点
    - 延迟小于 1ms 会被转换成 1ms，此时按代码顺序执行（因为时间优先级是一样的）
      - setTimeout(()=>console.log(0.5),0.5);setTimeout(()=>console.log(0),0);
    - 延迟小于 4ms 的，统一推入在 4ms 时的宏任务队列中，延迟越低的时间优先级越高：比如延迟 2ms 比 延迟 3ms 先执行，但都是在延迟 4ms 后才可能触发
      - setTimeout(()=>console.log(2),2);setTimeout(()=>console.log(1),1);
      - setTimeout(()=>console.log(2),2);setTimeout(()=>console.log(1),1);setTimeout(()=>console.log(0.5),0.5);setTimeout(()=>console.log(0),0);

# WebWorker 和 SharedWorker

- 非要用到计算密集型的处理时，可以使用 webworker 或 SharedWorker 新建一个 js 任务，受控于主线程
- 使用 postMessage API 与主线程进行通讯
- WebWorker 是页面 Renderer 进程创建的线程
- SharedWorker 是由浏览器单独创建的含有 JS 线程的进程，被所有的 Renderer 进程所共享，在浏览器中，最多只能存在一个 SharedWorker。

# 浏览器的渲染流程

- 打开浏览器，启动浏览器进程
- 输入有效地址并回车后，
  - 创建页面渲染进程
  - 启动浏览器进程中的下载线程进行请求
- 获取到内容后，使用刚刚创建的页面渲染进程进行渲染
  - 解析 html 生产 DOM 树。
  - 解析 CSS 规则。
  - 根据 DOM Tree 和 CSS Tree 生成 Render Tree。
    - style 放到 dom 前面可以一次性绘制完毕，如果放在后面的话就得再渲染一次
  - 根据 Render tree 进行 layout，负责各个元素节点的尺寸、位置计算。
  - 绘制 Render tree(painting)，绘制页面像素信息。
  - 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。
- script 会按代码顺序，与渲染互斥执行
- 全部完成后会把 onload 添加到事件队列里等待执行

# passive 作用

- .passive 回调函数不会立即执行，即不会阻塞
- 在移动端的 scroll 事件中效果明显
- 此种情况下，在回调中触发 preventDefault 是无效的
  - 不用 passive 每次触发事件都会等回调函数完全执行之后，才继续下一次事件，因为不知道会不会被 preventDefault
- 原理是 addeventListener 的第三个参数可以是对象，其中一个属性用于判断是否需要在冒泡结束后检查有没有 preventDefault，传 false 的话就会跳过这个检查
- 跳过检查后，就可以把 js 函数和浏览器行为解耦，使用双线程来执行渲染（浏览器的内核线程和合成线程），所以能提高性能
- 具体怎么个优化方法这块，挺深的。从 16 年中旬的 chrome51 开始支持，可以看下https://blog.csdn.net/dj0379/article/details/52883315 和 https://www.cnblogs.com/ziyunfei/p/5545439.html
- 内核线程和用户线程 https://blog.csdn.net/gatieme/article/details/51892437
